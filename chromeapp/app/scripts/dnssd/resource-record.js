/* global exports, require */
'use strict';

var byteArray = require('./byte-array-sem');
var dnsUtil = require('./dns-util');

var NUM_OCTETS_TYPE = 2;
var NUM_OCTETS_CLASS = 2;
var NUM_OCTETS_TTL = 4;
var NUM_OCTETS_RESOURCE_DATA_LENGTH = 2;

/** An A Record has for bytes, all representing an IP address. */
var NUM_OCTETS_RESOURCE_DATA_A_RECORD = 4;

/**
 * A resource record (RR) is a component of a DNS message. They share a similar
 * structure but contain different information.
 *
 * Each resource record begins with a domain name, which can be a variable
 * number of bytes.
 *
 * Then is a 2-octet type (e.g. A, SRV, etc).
 *
 * Then is a 2-octet class (e.g. IN for internet).
 *
 * Then is a 4-octet TTL.
 *
 * Then is a variable number of bytes representing the data in record. The
 * first 2-octets are the length of the following data. The structure of that
 * data depends on the type of the record.
 *
 * Information here is based on 'TCP/IP Illustrated, Volume 1' by Stevens and
 * on the Bonjour Overview page provided by Apple:
 *
 * https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/NetServices/Articles/NetServicesArchitecture.html#//apple_ref/doc/uid/20001074-SW1
 */

var dnsCodes = require('./dns-codes-sem');

/**
 * An A record. A records respond to queries for a domain name to an IP
 * address.
 *
 * domainName: the domain name, e.g. www.example.com
 * ttl: the time to live
 * ipAddress: the IP address of the domainName. This must be a string
 *   representation (e.g. '192.3.34.17').
 * recordClass: the class of the record type. This is optional, and if not
 *   present or is not truthy will be set as IN for internet traffic.
 */
exports.ARecord = function ARecord(
  domainName,
  ttl,
  ipAddress,
  recordClass
) {
  if (!(this instanceof ARecord)) {
    throw new Error('ARecord must be called with new');
  }

  if ((typeof ipAddress) !== 'string') {
    throw new Error('ipAddress must be a String: ' + ipAddress);
  }
  
  if (!recordClass) {
    recordClass = dnsCodes.CLASS_CODES.IN;
  }

  this.recordType = dnsCodes.RECORD_TYPES.A;
  this.recordClass = recordClass;

  this.domainName = domainName;
  this.ttl = ttl;
  this.ipAddress = ipAddress;
};

/**
 * Get the A Record as a ByteArray object.
 *
 * The DNS spec indicates that an A Record is represented in byte form as
 * follows.
 *
 * The common fields as indicated in getCommonFieldsAsByteArray.
 *
 * 2 octets representing the number 4, to indicate that 4 bytes follow.
 *
 * 4 octets representing a 4-byte IP address
 */
exports.ARecord.prototype.convertToByteArray = function() {
  var result = exports.getCommonFieldsAsByteArray(
    this.domainName,
    this.recordType,
    this.recordClass,
    this.ttl
  );

  // First we add the length of the resource data.
  result.push(
    NUM_OCTETS_RESOURCE_DATA_A_RECORD, 
    NUM_OCTETS_RESOURCE_DATA_LENGTH
  );

  // Then add the IP address itself.
  var ipStringAsBytes = dnsUtil.getIpStringAsByteArray(this.ipAddress);
  result.append(ipStringAsBytes);

  return result;
};

/**
 * Create an A Record from a ByteArrayReader object. The reader should be at
 * the correct cursor position, at the domain name of the A Record.
 */
exports.createARecordFromReader = function(reader) {
  var commonFields = exports.getCommonFieldsFromByteArrayReader(reader);

  if (commonFields.rrType !== dnsCodes.RECORD_TYPES.A) {
    throw new Error(
      'De-serialized A Record does not have A Record type: ' + 
        commonFields.rrType
    );
  }

  // And now we recover just the resource length and resource data.
  var resourceLength = reader.getValue(NUM_OCTETS_RESOURCE_DATA_LENGTH);

  // For an A Record this should always be 4.
  if (resourceLength !== NUM_OCTETS_RESOURCE_DATA_A_RECORD) {
    throw new Error(
      'Recovered resource length does not match expected value for A ' +
        '  Record: ' +
        resourceLength
    );
  }

  var ipString = dnsUtil.getIpStringFromByteArrayReader(reader);

  var result = new exports.ARecord(
    commonFields.domainName,
    commonFields.ttl,
    ipString,
    commonFields.rrClass
  );

  return result;
};

/**
 * A PTR record. PTR records respond to a query for a service type (eg
 * '_printer._tcp.local'. They return the name of an instance offering the
 * service (eg 'Printsalot._printer._tcp.local').
 *
 * serviceType: the string representation of the service that has been queried
 *   for.
 * ttl: the time to live
 * instanceName: the name of the instance providing the serviceType
 */
exports.PtrRecord = function PtrRecord(serviceType, ttl, instanceName) {
  if (!(this instanceof PtrRecord)) {
    throw new Error('PtrRecord must be called with new');
  }
  this.recordType = dnsCodes.RECORD_TYPES.PTR;
  this.recordClass = dnsCodes.CLASS_CODES.IN;

  this.serviceType = serviceType;
  this.ttl = ttl;
  this.instanceName = instanceName;
};

/**
 * An SRV record. SRV records map the name of a service instance to the
 * information needed to connect to the service. 
 *
 * instanceTypeDomain: the name being queried for, e.g.
 *   'PrintsALot._printer._tcp.local'
 * ttl: the time to live
 * priority: the priority of this record if multiple records are found. This
 *   must be a number from 0 to 65535.
 * weight: the weight of the record if two records have the same priority. This
 *   must be a number from 0 to 65535.
 * port: the port number on which to find the service. This must be a number
 *   from 0 to 65535.
 * targetDomain: the domain hosting the service (e.g. 'blackhawk.local')
 */
exports.SrvRecord = function SrvRecord(
  instanceTypeDomain,
  ttl,
  priority,
  weight,
  port,
  targetDomain
) {
  if (!(this instanceof SrvRecord)) {
    throw new Error('SrvRecord must be called with new');
  }
  this.recordType = dnsCodes.RECORD_TYPES.SRV;
  this.recordClass = dnsCodes.CLASS_CODES.IN;

  this.instanceTypeDomain = instanceTypeDomain;
  this.ttl = ttl;
  this.priority = priority;
  this.weight = weight;
  this.port = port;
  this.targetDomain = targetDomain;
};

/**
 * Get the common components of a RR as a ByteArray. As specified by the DNS
 * spec and 'TCP/IP Illustrated, Volume 1' by Stevens, the format is as
 * follows:
 *
 * Variable number of octets encoding the domain name to which the RR is
 *   responding.
 *
 * 2 octets representing the RR type
 *
 * 2 octets representing the RR class
 *
 * 4 octets representing the TTL
 */
exports.getCommonFieldsAsByteArray = function(
  domainName,
  rrType,
  rrClass,
  ttl
) {
  var result = new byteArray.ByteArray();

  var domainNameAsBytes = dnsUtil.getDomainAsByteArray(domainName);
  result.append(domainNameAsBytes);

  result.push(rrType, NUM_OCTETS_TYPE);
  result.push(rrClass, NUM_OCTETS_CLASS);
  result.push(ttl, NUM_OCTETS_TTL);

  return result;
};

/**
 * Extract the common fields from the reader as encoded by
 * getCommonFieldsAsByteArray.
 *
 * Returns an object with fields domainName, rrType, rrClass, and ttl.
 */
exports.getCommonFieldsFromByteArrayReader = function(reader) {
  var domainName = dnsUtil.getDomainFromByteArrayReader(reader);
  var rrType = reader.getValue(NUM_OCTETS_TYPE);
  var rrClass = reader.getValue(NUM_OCTETS_CLASS);
  var ttl = reader.getValue(NUM_OCTETS_TTL);

  var result = {
    domainName: domainName,
    rrType: rrType,
    rrClass: rrClass,
    ttl: ttl
  };

  return result;
};
